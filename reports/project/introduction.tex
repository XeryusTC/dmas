In modern times, a lot of information is spread out among many sources.
One of these sources is the internet, where a large collection of different entities need to sychronize and work together to achieve a common goal. Multi agent systems is not much different than that. Various agents with different capabilities have to sychronize and colaborate in order to achive a common goal. The domain where the agents come in handy expands more and more which has resulted many applications based on multi agent systems as well as many argorithms (with various uses) that come allong with the agents themselves. 

\subsection{Problem discription}
In this particular paper we are discribing a situation where various robots work together under a common coordinator. In our case that goal is to retrieve people who have been traped in a maze. To this end, many different situations have to be taken into account for the smooth extraction of the rescuee, such as robot collision avoidance, robot distruction or prioritization between targets. Another major pithole is the computation of all the data available. For a small area, a regular desktop power machine would be sufficient, but it would - most likely - not scale up properly. In that case we need the agents to be able to outsorce the computation needed to a higher end machine to do the computation for them.


\subsection{State of the Art}
We base our approach on the follwoing two papers which describe the state of the art for our domain. 
\cite{intframe}.

\subsection{New Idea}
The main procedure is as follows; first the robots are sent into the uncharted maze. As they move around they map the maze and they sent this information back to the coordinator (another agent) which keeps track of the map, as well as the movements of the agents and plans ahead how the agents should move. Our plan howver is to elaborate on the above even more. As there are multiple ways for the agents to communicate we plan on testing two different approahes and see which one works better. The first approach is more centralized where the low-level agents are only capable of communicating with the coordinator and in turn, the coordinator has to update the database or use the pathplaner in order to find another path for the agent in case he is stuck. Thus all the communications are done through a central point which may result to a double edge blade, since, onthe possitive side we have one agent taking all the desicions but it is also a potential bottleneck and a single-point-failure. The second approach is less centralized. The low-level agents can directly communicate with the database and update it themselves. In case where one of the agents gets stuck, only then does the agent contuct the coordinator, the coordinator informs the pathplanner and only then the pathplanner communicates with the agent to give him the next path the agent should follow. 